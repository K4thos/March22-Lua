/*
	RPYtoLua 
	A tool for converting RPY to March22-Lua-compliant Lua

	By Sam Lynch
*/

#define VERSION_MAJOR 0
#define VERSION_MINOR 3
#define VERSION_PATCH 0

#include <string>
#include <iostream>
#include <codecvt>
#include <vector>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <chrono>

enum LUAFUNCTION {
	PLAY_SOUND,
	CHANGE_BACKGROUND,
	CHANGELINE
};

int LoadScriptIntoVector(const wchar_t* _input, std::vector<std::wstring>& _vector);
std::vector<std::wstring> GetLoadedBackgroundsFromVector(std::vector<std::wstring>& _vector);
std::vector<std::wstring> GetLoadedSFXFromVector(std::vector<std::wstring>& _vector);
unsigned int SplitString(const std::wstring &txt, std::vector<std::wstring> &strs, char ch);
std::vector<std::wstring> GetLinesFromVector(std::vector<std::wstring>& _vector);
void WriteCompiledScript(std::vector<std::wstring>& _backgrounds, std::vector<std::wstring>& _lines, std::vector<std::wstring>& _sfx);
int LoadTXTIntoVector(const char* _file, std::vector<std::wstring>& _vector);
std::wstring CreateLuaFunction(LUAFUNCTION _function, std::wstring _param, bool _newline = false, bool _prefixsuffix = false);

std::vector<std::wstring> CHARACTER_NAMES;
std::vector<std::wstring> CHARACTER_NAMES_FIXED;

int main(void)
{
	std::vector<std::wstring> SCRIPT;
	std::vector<std::wstring> BACKGROUNDS;
	std::vector<std::wstring> SFX;
	std::vector<std::wstring> LINES;

	LoadTXTIntoVector("./charnames.txt", CHARACTER_NAMES);
	LoadTXTIntoVector("./charnames_fixed.txt", CHARACTER_NAMES_FIXED);

	LoadScriptIntoVector(L"./test.rpy", SCRIPT);
	
	BACKGROUNDS =  GetLoadedBackgroundsFromVector(SCRIPT);
	SFX = GetLoadedSFXFromVector(SCRIPT);
	LINES = GetLinesFromVector(SCRIPT);


	WriteCompiledScript(BACKGROUNDS, LINES, SFX);
	printf("\nsuccesful!");

	return 0;
}

int LoadTXTIntoVector(const char* _file, std::vector<std::wstring>& _vector)
{
	std::wifstream inputFile;
	inputFile.open(_file);

	if (!inputFile) {
		printf("Failed to load: %s\n", _file);
		return -1;
	};

	std::wstring line;
	while (std::getline(inputFile, line))
	{
		_vector.push_back(line);
	};

	inputFile.close();
	return 0;
};

void WriteCompiledScript(std::vector<std::wstring>& _backgrounds, std::vector<std::wstring>& _lines, std::vector<std::wstring>& _sfx)
{
	std::wofstream textOutput("./test.lua");
	//textOutput.imbue(std::locale(std::locale::empty(), new std::codecvt_utf8<wchar_t, 0x10ffff, std::generate_header>));
	textOutput.imbue(std::locale(std::locale::empty(), new std::codecvt_utf8<wchar_t, 0x10ffff>));
	//textOutput.imbue(std::locale("en_USutf8"));

	textOutput << L"-- This file was automatically generated by RPYtoLua v" << VERSION_MAJOR << L"." << VERSION_MINOR << L"." << VERSION_PATCH; 
	textOutput << L"\n-- For use with March22-Lua\n-- By Sam Lynch\n\n";
	textOutput << L"dofile(\"app0:/LUA_CLASSES/Line.lua\");\n\n";
	textOutput << L"LOADEDBACKGROUNDS = {};\nLOADEDSFX = {};\n\n";

	for (size_t i = 0; i < _backgrounds.size(); i++)
	{
		textOutput << _backgrounds.at(i);
		percentage = (((float)i / (float)_backgrounds.size()) * (float)40);
		textOutput << L"UpdateLoadingProgress(" << percentage << L");\n";
	}
	for (size_t i = 0; i < _sfx.size(); i++)
	{
		textOutput << _sfx.at(i);
		percentage = ((((float)i / (float)_sfx.size()) * (float)40) + 40);
		textOutput << L"UpdateLoadingProgress(" << percentage << L");\n";
	}

	textOutput << "\nACTIVE_SCRIPT = {\n";
	for (size_t i = 0; i < _lines.size()-1; i++)
	{
		textOutput << "	" << _lines.at(i);
	}

	// This is hack to stop a comma appearing at the end of the table
	std::wstring temp = _lines.at(_lines.size() - 1);
	temp.pop_back();
	temp.pop_back();
	textOutput << "	" << temp << '\n';

	textOutput << "};\n";
	textOutput << L"UpdateLoadingProgress(100);\n";
	textOutput.close();
	return;
}

std::wstring CreateLuaFunction(LUAFUNCTION _function, std::wstring _param, bool _newline, bool _prefixsuffix)
{
	std::wstring result = L"";
	if (_prefixsuffix)
	{
		result += L"function() ";
	};

	switch (_function)
	{
		case PLAY_SOUND:
			result += std::wstring(L"Sound.play(LOADEDSFX[\"" + _param + L"\"], NO_LOOP);");
			break;
		case CHANGE_BACKGROUND:
			result += std::wstring(L"March22.ACTIVEBACKGROUND = LOADEDBACKGROUNDS[\"" + _param + L"\"];");
			break;
		case CHANGELINE:
			result += L"March22.NextLine(); ";
			_newline = false;
			break;
	};

	if (_newline == true)
	{
		result += L"March22.NextLine(); ";
	};

	if (_prefixsuffix)
	{
		result += L"end ";
	};
	return result;
};

std::vector<std::wstring> GetLinesFromVector(std::vector<std::wstring>& _vector)
{
	//Line.new("", Color.new(255, 255, 255), "A light breeze causes the naked branches overhead to rattle like wooden windchimes."),
	std::wstring COLOR = L"Color.new(255, 255, 255), ";
	std::vector<std::wstring> result;

	enum TYPE {UNKNOWN, PLAYSOUND, PLAYMUSIC, CHANGEBACKGROUND, SPEECH, NARRATIVE};

	for (size_t i = 0; i < _vector.size(); i++)
	{
		TYPE type = UNKNOWN;
		std::vector<std::wstring> splitString;
		SplitString(_vector.at(i), splitString, ' ');
		std::wstring tempStr = L"Line.new(";
		if (_vector.at(i).at(0) == L'\"') // narrative
		{
			size_t n = std::count(_vector.at(i).begin(), _vector.at(i).end(), '\"');
			if (n > 2)
			{
				type = SPEECH;
				tempStr += splitString.at(0);
			}
			else
			{
				tempStr += L"\"\"";
				type = NARRATIVE;
				//tempStr += _vector.at(i);
			};
		}
		else
		{
			if (splitString.at(0) == L"play")
			{
				if (splitString.at(1) == L"sound")
				{
					type = PLAYSOUND;
				}
				else if(splitString.at(0) == L"music")
				{
					type = PLAYMUSIC;
				}
			}
			else if (splitString.at(0) == L"scene")
			{
				type = CHANGEBACKGROUND;
			}
			
			bool characterNameFound = false;
			for (size_t chr = 0; chr < CHARACTER_NAMES.size(); chr++)
			{
				if (splitString.at(0) == CHARACTER_NAMES.at(chr))
				{
					characterNameFound = true;
					type = SPEECH;
					tempStr += (L"\""+CHARACTER_NAMES_FIXED.at(chr)+L"\"");
				}
			}
			if(!characterNameFound) tempStr += L"\"\"";
		}
		tempStr += L", ";
		tempStr += COLOR;
		if (type == NARRATIVE)
		{
			tempStr += _vector.at(i);
		}
		else if (type == SPEECH)
		{
			std::wstring temp = _vector.at(i);
			temp.erase(0, splitString.at(0).size() + 1);
			tempStr += temp;
		}
		else
		{
			tempStr += L"\"\"";
		}
		if (type == PLAYSOUND)
		{
			tempStr += L", ";
			tempStr += CreateLuaFunction(LUAFUNCTION::PLAY_SOUND, splitString.at(2), true, true);
			tempStr += L"),\n";
		}
		else if (type == CHANGEBACKGROUND)
		{
			tempStr += L", ";
			if (splitString.size() >= 3)
			{
				tempStr += CreateLuaFunction(LUAFUNCTION::CHANGE_BACKGROUND, splitString.at(2), true, true);
			}
			else
			{
				tempStr += CreateLuaFunction(LUAFUNCTION::CHANGE_BACKGROUND, splitString.at(1), true, true);
			}
			tempStr += L"),\n";
		}
		else if(type == TYPE::NARRATIVE || type == TYPE::SPEECH)
		{
			//tempStr += (L", " + CreateLuaFunction(LUAFUNCTION::CHANGELINE, L"", true, true) + L"),\n");
			tempStr += (L"),\n");
		}
		else
		{
			tempStr += (L", " + CreateLuaFunction(LUAFUNCTION::CHANGELINE, L"", true, true) + L"),\n");
		};
		result.push_back(tempStr);
	};
	return result;
}

std::vector<std::wstring> GetLoadedSFXFromVector(std::vector<std::wstring>& _vector)
{
	std::vector<std::wstring> result;
	std::vector<std::wstring> loadedSFXTemp;

	for (size_t i = 0; i < _vector.size(); i++)
	{
		std::wstring isScene = _vector.at(i).substr(0, 4);
		if (isScene == L"play")
		{
			std::vector<std::wstring> splitStr;
			SplitString(_vector.at(i), splitStr, ' ');
			std::wstring sfxEntry = L"";

			// March22 handles events and backgrounds the same way
			if (splitStr.at(1) == L"sound")
			{
				bool alreadyLoaded = false;
				for (size_t ch = 0; ch < loadedSFXTemp.size(); ch++)
				{
					if (loadedSFXTemp.at(ch) == splitStr.at(2))
					{
						alreadyLoaded = true;
						break;
					};
				}
				if (!alreadyLoaded)
				{
					sfxEntry += L"LOADEDSFX[\"";
					sfxEntry += splitStr.at(2);
					sfxEntry += L"\"] = Sound.openOgg(\"app0:/sfx/";
					sfxEntry += splitStr.at(2);
					sfxEntry += L".ogg\");\n";
					result.push_back(sfxEntry);
					loadedSFXTemp.push_back(splitStr.at(2));
				};
			}
		};
	}

	return result;
}

std::vector<std::wstring> GetLoadedBackgroundsFromVector(std::vector<std::wstring>& _vector)
{
	//LOADEDBACKGROUNDS = {};
	//LOADEDBACKGROUNDS["op_snowywoods"] = Graphics.loadImage("app0:/graphics/backgrounds/op_snowywoods.jpg");
	std::vector<std::wstring> result;
	std::vector<std::wstring> loadedBackgroundsTemp;

	for (size_t i = 0; i < _vector.size(); i++)
	{
		std::wstring isScene = _vector.at(i).substr(0, 5);
		if (isScene == L"scene")
		{
			std::vector<std::wstring> splitStr;
			SplitString(_vector.at(i), splitStr, ' ');
			std::wstring backgroundEntry = L"";

			// March22 handles events and backgrounds the same way
			if (splitStr.at(1) == L"ev" || splitStr.at(1) == L"bg") 
			{
				bool alreadyLoaded = false;
				for (size_t ch = 0; ch < loadedBackgroundsTemp.size(); ch++)
				{
					if (loadedBackgroundsTemp.at(ch) == splitStr.at(2))
					{
						alreadyLoaded = true;
						break;
					};
				}
				if (!alreadyLoaded)
				{
					backgroundEntry += L"LOADEDBACKGROUNDS[\"";
					backgroundEntry += splitStr.at(2);
					backgroundEntry += L"\"] = Graphics.loadImage(\"app0:/graphics/backgrounds/";
					backgroundEntry += splitStr.at(2);
					backgroundEntry += L".jpg\");\n";
					result.push_back(backgroundEntry);
					loadedBackgroundsTemp.push_back(splitStr.at(2));
				};
			}
			else if (splitStr.at(1) == L"bl") // black
			{

			}
			else if (splitStr.at(1) == L"wh") // white
			{

			};
		};
	}

	return result;
}

unsigned int SplitString(const std::wstring &txt, std::vector<std::wstring> &strs, char ch)
{
	unsigned int pos = txt.find(ch);
	unsigned int initialPos = 0;
	strs.clear();

	// Decompose statement
	while (pos != std::string::npos) {
		strs.push_back(txt.substr(initialPos, pos - initialPos + 1));
		initialPos = pos + 1;

		pos = txt.find(ch, initialPos);
	}

	// Add the last one
	strs.push_back(txt.substr(initialPos, std::min(pos, txt.size()) - initialPos + 1));

	for (size_t i = 0; i < strs.size(); i++)
	{
		strs.at(i).erase(std::remove_if(strs.at(i).begin(), strs.at(i).end(), iswspace), strs.at(i).end());
	}

	return strs.size();
};

int LoadScriptIntoVector(const wchar_t* _input, std::vector<std::wstring>& _vector)
{
	// Load file
	std::locale ulocale(std::locale(), new std::codecvt_utf8<wchar_t>);
	std::wifstream inputFile;
	inputFile.open(_input);
	inputFile.imbue(ulocale);

	// Check file
	if (!inputFile) {
		wprintf(L"Failed to load: %s\n", _input);
		return -1;
	};

	// Load meaningful lines into vector
	std::wstring line;
	while (std::getline(inputFile, line))
	{
		if (line != L"") {
			//std::wstringstream iss(line);
			//::wstring item;
			//iss >> item;

			_vector.push_back(line);
		};
	};
	inputFile.seekg(0, inputFile.beg);

	// Cleanup
	inputFile.close();
	return 0;
};