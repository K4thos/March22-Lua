/*
	RPYtoLua 
	A tool for converting RPY to March22-Lua-compliant Lua

	By Sam Lynch
*/

#define VERSION_MAJOR 0
#define VERSION_MINOR 4
#define VERSION_PATCH 0

#include <string>
#include <iostream>
#include <codecvt>
#include <vector>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <chrono>

enum LUAFUNCTION {
	PLAY_SOUND,
	CHANGE_BACKGROUND,
	CHANGELINE,
	CLEAR_CHARACTER, 
	NEW_CHARACTER
};

struct Character {
	std::vector<std::wstring> sprites;
	std::wstring name;
	Character()
	{
		name = L"";
	};
};

int LoadScriptIntoVector(const wchar_t* _input, std::vector<std::wstring>& _vector);
std::vector<std::wstring> GetLoadedBackgroundsFromVector(std::vector<std::wstring>& _vector);
std::vector<std::wstring> GetLoadedSFXFromVector(std::vector<std::wstring>& _vector);
unsigned int SplitString(const std::wstring &txt, std::vector<std::wstring> &strs, char ch);
std::vector<std::wstring> GetLinesFromVector(std::vector<std::wstring>& _vector);
void WriteCompiledScript(std::vector<std::wstring>& _backgrounds, std::vector<std::wstring>& _lines, std::vector<std::wstring>& _sfx, std::vector<Character>& _characters);
int LoadTXTIntoVector(const char* _file, std::vector<std::wstring>& _vector);
std::wstring CreateLuaFunction(LUAFUNCTION _function, std::wstring _param, bool _newline = false, bool _prefixsuffix = false, std::wstring _param2 = L"", std::wstring _param3 = L"", std::wstring _param4 = L"", std::wstring _param5 = L"");
std::vector<Character> GetLoadedCharactersFromVector(std::vector<std::wstring>& _vector);

bool isCharacter(std::wstring _name);

std::vector<std::wstring> CHARACTER_NAMES;
std::vector<std::wstring> CHARACTER_NAMES_FIXED;

int main(void)
{
	std::vector<std::wstring> SCRIPT;
	std::vector<std::wstring> BACKGROUNDS;
	std::vector<Character> CHARACTERS;
	std::vector<std::wstring> SFX;
	std::vector<std::wstring> LINES;

	LoadTXTIntoVector("./charnames.txt", CHARACTER_NAMES);
	LoadTXTIntoVector("./charnames_fixed.txt", CHARACTER_NAMES_FIXED);

	LoadScriptIntoVector(L"./test.rpy", SCRIPT);
	
	CHARACTERS = GetLoadedCharactersFromVector(SCRIPT);
	BACKGROUNDS =  GetLoadedBackgroundsFromVector(SCRIPT);
	SFX = GetLoadedSFXFromVector(SCRIPT);
	LINES = GetLinesFromVector(SCRIPT);


	WriteCompiledScript(BACKGROUNDS, LINES, SFX, CHARACTERS);
	printf("\nsuccesful!");

	return 0;
}

int LoadTXTIntoVector(const char* _file, std::vector<std::wstring>& _vector)
{
	std::wifstream inputFile;
	inputFile.open(_file);

	if (!inputFile) {
		printf("Failed to load: %s\n", _file);
		return -1;
	};

	std::wstring line;
	while (std::getline(inputFile, line))
	{
		_vector.push_back(line);
	};

	inputFile.close();
	return 0;
};

std::wstring GenerateCharacterArray(Character& _char)
{
	//March22.CHARACTERS["shizune"] = Character.new("shizune", {"normal"}); 
	std::wstring result = L"March22.CHARACTERS[\"";
	result += _char.name;
	result += L"\"] = Character.new(\"";
	result += _char.name;
	result += L"\", {\n";

	for (size_t i = 0; i < _char.sprites.size(); i++)
	{
		result += L"	\"";
		std::wstring temp = _char.sprites.at(i);
		temp.erase(std::remove(temp.begin(), temp.end(), ':'), temp.end());
		result += temp;
		result += L"\"";

		// if not the last emotion
		if ( !(i == (_char.sprites.size() - 1) ) )
		{
			result += L",\n";
		}
	}
	result += L"});\n\n";

	return result;
}

void WriteCompiledScript(std::vector<std::wstring>& _backgrounds, std::vector<std::wstring>& _lines, std::vector<std::wstring>& _sfx, std::vector<Character>& _characters)
{
	std::wofstream textOutput("./script-a1-monday.lua");
	//textOutput.imbue(std::locale(std::locale::empty(), new std::codecvt_utf8<wchar_t, 0x10ffff, std::generate_header>));
	textOutput.imbue(std::locale(std::locale::empty(), new std::codecvt_utf8<wchar_t, 0x10ffff>));
	//textOutput.imbue(std::locale("en_USutf8"));

	textOutput << L"-- This file was automatically generated by RPYtoLua v" << VERSION_MAJOR << L"." << VERSION_MINOR << L"." << VERSION_PATCH; 
	textOutput << L"\n-- For use with March22-Lua\n-- By Sam Lynch\n\n";
	textOutput << L"dofile(\"app0:/LUA_CLASSES/Line.lua\");\ndofile(\"app0:/March22_background.lua\");\n\n";
	textOutput /*<< L"LOADEDBACKGROUNDS = {};" */ << "\nLOADEDSFX = {};\n\n";

	float percentage = 0.0f;
	for (size_t i = 0; i < _characters.size(); i++)
	{
		percentage = ((((float)i / (float)_characters.size()) * (float)20));
		textOutput << L"UpdateLoadingProgress(" << (int)percentage << L");\n";
		textOutput << GenerateCharacterArray(_characters.at(i));
	}

	for (size_t i = 0; i < _backgrounds.size(); i++)
	{
		percentage = ((((float)i / (float)_backgrounds.size()) * (float)40) + 20);
		textOutput << L"UpdateLoadingProgress(" << (int)percentage << L");\n";
		textOutput << _backgrounds.at(i);
	}
	for (size_t i = 0; i < _sfx.size(); i++)
	{
		percentage = ((((float)i / (float)_sfx.size()) * (float)40) + 60);
		textOutput << L"UpdateLoadingProgress(" << (int)percentage << L");\n";
		textOutput << _sfx.at(i);
	}

	textOutput << "\nACTIVE_SCRIPT = {\n";
	for (size_t i = 0; i < _lines.size()-1; i++)
	{
		textOutput << "	" << _lines.at(i);
	}

	// This is hack to stop a comma appearing at the end of the table
	std::wstring temp = _lines.at(_lines.size() - 1);
	temp.pop_back();
	temp.pop_back();
	textOutput << "	" << temp << '\n';

	textOutput << "};\n";
	textOutput << L"UpdateLoadingProgress(100);\n";
	textOutput.close();
	return;
}

std::wstring CreateLuaFunction(LUAFUNCTION _function, std::wstring _param, bool _newline, bool _prefixsuffix, std::wstring _param2, std::wstring _param3, std::wstring _param4, std::wstring _param5)
{
	std::wstring result = L"";
	if (_prefixsuffix)
	{
		result += L"function() ";
	};

	switch (_function)
	{
		case PLAY_SOUND:
			result += std::wstring(L"Sound.play(LOADEDSFX[\"" + _param + L"\"], NO_LOOP);");
			break;
		case CHANGE_BACKGROUND:
			result += std::wstring(L"March22.ACTIVEBACKGROUND = LOADEDBACKGROUNDS[\"" + _param + L"\"];");
			break;
		case CLEAR_CHARACTER:
			result += std::wstring(L"March22.ClearCharacter(\""+ _param + L"\");");
			break;
		case NEW_CHARACTER:
			if (_param3 != L"" && _param3 != L"charachange")
			{// param3 = position, param = name, param2 = emotion
				//March22.AddCharacterToActive(_x, _charname, _emotion, _anim, _animfunc, _speed)
				if (_param4 != L"")
				{
					result += std::wstring(L"March22.AddCharacterToActive(\"" + _param3 + L"\", \"" + _param + L"\", \"" + _param2 + L"\", \"" + _param4 + L"\", function() March22.NextLine(); end, 0.05);");
				}
				else
				{
					std::wstring temp = _param2;
					temp.erase(std::remove(temp.begin(), temp.end(), ':'), temp.end());
					result += std::wstring(L"March22.AddCharacterToActive(\"" + _param3 + L"\", \"" + _param + L"\", \"" + temp + L"\");");
				}
			}
			else
			{
				result += std::wstring(L"March22.AddCharacterToActive(\"None\", \"" + _param + L"\", \"" + _param2 + L"\");");
				_newline = true;
			}
			break;
		case CHANGELINE:
			result += L"March22.NextLine(); ";
			_newline = false;
			break;
	};

	if (_newline == true)
	{
		result += L"March22.NextLine(); ";
	};

	if (_prefixsuffix)
	{
		result += L"end ";
	};
	return result;
};

bool isCharacter(std::wstring _name)
{
	for (size_t i = 0; i < CHARACTER_NAMES.size(); i++)
	{
		if (CHARACTER_NAMES.at(i) == _name)
		{
			return true;
		};
	}
	return false;
};

std::wstring CheckForAnimation(std::vector<std::wstring>& _vector, size_t _pos)
{
	bool exit = false;
	int pos = _pos;
	while (exit == false || pos < (_pos+8))
	{
		pos++;
		if (pos < _vector.size())
		{
			std::vector<std::wstring> splitString;
			SplitString(_vector.at(pos), splitString, ' ');
			if (splitString.at(0) == L"with")
			{
				// found anim
				return splitString.at(1);
			}
		};
	}
	
	return L"";
}

std::vector<std::wstring> GetLinesFromVector(std::vector<std::wstring>& _vector)
{
	//Line.new("", Color.new(255, 255, 255), "A light breeze causes the naked branches overhead to rattle like wooden windchimes."),
	std::wstring COLOR = L"March22.WHITE_COLOUR, ";
	std::vector<std::wstring> result;

	enum TYPE {UNKNOWN, PLAYSOUND, PLAYMUSIC, CHANGEBACKGROUND, ADDSPRITE, CLEARSPRITE, SPEECH, NARRATIVE};

	for (size_t i = 0; i < _vector.size(); i++)
	{
		TYPE type = UNKNOWN;
		std::vector<std::wstring> splitString;
		SplitString(_vector.at(i), splitString, ' ');
		std::wstring tempStr = L"Line.new(";
		if (splitString.at(0).size() > 0 && splitString.at(0).at(0) == L'\"') // narrative
		{
			size_t n = std::count(_vector.at(i).begin(), _vector.at(i).end(), '\"');
			if (n > 2)
			{
				type = SPEECH;
				tempStr += splitString.at(0);
			}
			else
			{
				tempStr += L"\"\"";
				type = NARRATIVE;
				//tempStr += _vector.at(i);
			};
		}
		else
		{
			if (splitString.at(0) == L"play")
			{
				if (splitString.at(1) == L"sound")
				{
					type = PLAYSOUND;
				}
				else if(splitString.at(0) == L"music")
				{
					type = PLAYMUSIC;
				}
			}
			else if (splitString.at(0) == L"show")
			{
				type = ADDSPRITE;
			}
			else if (splitString.at(0) == L"hide")
			{
				type = CLEARSPRITE;
			}
			else if (splitString.at(0) == L"scene")
			{
				type = CHANGEBACKGROUND;
			}
			
			bool characterNameFound = false;
			for (size_t chr = 0; chr < CHARACTER_NAMES.size(); chr++)
			{
				if (splitString.at(0) == CHARACTER_NAMES.at(chr))
				{
					characterNameFound = true;
					type = SPEECH;
					tempStr += (L"\""+CHARACTER_NAMES_FIXED.at(chr)+L"\"");
				}
			}
			if(!characterNameFound) tempStr += L"\"\"";
		}
		tempStr += L", ";
		tempStr += COLOR;
		if (type == NARRATIVE)
		{
			tempStr += _vector.at(i);
		}
		else if (type == SPEECH)
		{
			std::wstring temp = _vector.at(i);
			temp.erase(0, splitString.at(0).size() + 1);
			temp.pop_back();
			tempStr += (L"\"\\"+temp+L"\\\"\"");
		}
		else
		{
			tempStr += L"\"\"";
		}

		if (type == PLAYSOUND)
		{
			tempStr += L", ";
			tempStr += CreateLuaFunction(LUAFUNCTION::PLAY_SOUND, splitString.at(2), true, true);
			tempStr += L"),\n";
		}
		else if (type == CHANGEBACKGROUND)
		{
			tempStr += L", ";
			if (splitString.size() >= 3)
			{
				tempStr += CreateLuaFunction(LUAFUNCTION::CHANGE_BACKGROUND, splitString.at(2), true, true);
			}
			else
			{
				tempStr += CreateLuaFunction(LUAFUNCTION::CHANGE_BACKGROUND, splitString.at(1), true, true);
			}
			tempStr += L"),\n";
		}
		else if(type == TYPE::ADDSPRITE)
		{
			//splitString.at(1)
			// show muto normal at center
			if (isCharacter(splitString.at(1)))
			{
				std::wstring animation = CheckForAnimation(_vector, i);
				if (animation == L"")
				{
					if (splitString.size() > 3 && splitString.at(3) == L"at")
					{
						tempStr += (L", " + CreateLuaFunction(LUAFUNCTION::NEW_CHARACTER, splitString.at(1), true, true, splitString.at(2), splitString.at(4)));
					}
					else
					{
						tempStr += (L", " + CreateLuaFunction(LUAFUNCTION::NEW_CHARACTER, splitString.at(1), true, true, splitString.at(2)));
					}
				}
				else
				{
					if (splitString.size() > 3 && splitString.at(3) == L"at")
					{
						tempStr += (L", " + CreateLuaFunction(
							LUAFUNCTION::NEW_CHARACTER, 
							splitString.at(1), 
							false, 
							true, 
							splitString.at(2), 
							splitString.at(4),
							animation
						));
					}
					else
					{
						tempStr += (L", " + CreateLuaFunction(LUAFUNCTION::NEW_CHARACTER, splitString.at(1), false, true, splitString.at(2),animation));
					}
				}
				tempStr += L"),\n";
			}
			else
			{
				tempStr += (L", " + CreateLuaFunction(LUAFUNCTION::CHANGELINE, L"", true, true) + L"),\n");
			}
		}
		else if (type == TYPE::CLEARSPRITE)
		{
			if (isCharacter(splitString.at(1)))
			{
				tempStr += (L", " + CreateLuaFunction(LUAFUNCTION::CLEAR_CHARACTER, splitString.at(1), true, true) + L"),\n");
			}
			else
			{
				tempStr += (L", " + CreateLuaFunction(LUAFUNCTION::CHANGELINE, L"", true, true) + L"),\n");
			}
		}
		else if (type == TYPE::SPEECH || type == TYPE::NARRATIVE)
		{
			//nothing
			tempStr += L"),\n";
		}
		else
		{
			tempStr += (L", " + CreateLuaFunction(LUAFUNCTION::CHANGELINE, L"", true, true) + L"),\n");
		};
		result.push_back(tempStr);
	};
	return result;
}

std::vector<Character> GetLoadedCharactersFromVector(std::vector<std::wstring>& _vector)
{
	std::vector<Character> result;

	for (size_t i = 0; i < _vector.size(); i++)
	{
		//show muto smile
		std::vector<std::wstring> splitString;
		SplitString(_vector.at(i), splitString, ' ');

		bool characterExists = false;
		bool emoteExists = false;

		if (splitString.at(0) == L"show")
		{
			// check if character name
			if ( isCharacter(splitString.at(1) ) )
			{
				for (size_t res = 0; res < result.size(); res++)
				{
					// if name already exists
					if (result.at(res).name == splitString.at(1))
					{
						characterExists = true;
						// check if emotion already exists
						for (size_t emo = 0; emo < result.at(res).sprites.size(); emo++)
						{
							if (result.at(res).sprites.at(emo) == splitString.at(2))
							{
								// emotion + character already exists, break it
								emoteExists = true;
								break;
							}
						}

						// emotion doesn't exist!
						if (emoteExists == false)
						{
							result.at(res).sprites.push_back(splitString.at(2));
							emoteExists = true;
						};
						// emotion doesn't exist!

						if (characterExists) break;
					}
				}
				// character doesn't exist!
				if (characterExists == false)
				{
					Character newChar;
					newChar.name = splitString.at(1);
					newChar.sprites.push_back(splitString.at(2));
					result.push_back(newChar);
				};
				// character doesn't exist!
			}
		}
	};

	return result;
};

std::vector<std::wstring> GetLoadedSFXFromVector(std::vector<std::wstring>& _vector)
{
	std::vector<std::wstring> result;
	std::vector<std::wstring> loadedSFXTemp;

	for (size_t i = 0; i < _vector.size(); i++)
	{
		if (_vector.at(i).size() < 4)
		{
			//do nothing
		}
		else
		{
			std::wstring isScene = _vector.at(i).substr(0, 4);
			if (isScene == L"play")
			{
				std::vector<std::wstring> splitStr;
				SplitString(_vector.at(i), splitStr, ' ');
				std::wstring sfxEntry = L"";

				// March22 handles events and backgrounds the same way
				if (splitStr.at(1) == L"sound")
				{
					bool alreadyLoaded = false;
					for (size_t ch = 0; ch < loadedSFXTemp.size(); ch++)
					{
						if (loadedSFXTemp.at(ch) == splitStr.at(2))
						{
							alreadyLoaded = true;
							break;
						};
					}
					if (!alreadyLoaded)
					{
						sfxEntry += L"LOADEDSFX[\"";
						sfxEntry += splitStr.at(2);
						sfxEntry += L"\"] = Sound.openOgg(\"app0:/sfx/";
						sfxEntry += splitStr.at(2);
						sfxEntry += L".ogg\");\n";
						result.push_back(sfxEntry);
						loadedSFXTemp.push_back(splitStr.at(2));
					};
				}
			};
		};
	}

	return result;
}

std::vector<std::wstring> GetLoadedBackgroundsFromVector(std::vector<std::wstring>& _vector)
{
	//LOADEDBACKGROUNDS = {};
	//LOADEDBACKGROUNDS["op_snowywoods"] = Graphics.loadImage("app0:/graphics/backgrounds/op_snowywoods.jpg");
	std::vector<std::wstring> result;
	std::vector<std::wstring> loadedBackgroundsTemp;

	for (size_t i = 0; i < _vector.size(); i++)
	{
		std::wstring isScene = _vector.at(i).substr(0, 5);
		if (isScene == L"scene")
		{
			std::vector<std::wstring> splitStr;
			SplitString(_vector.at(i), splitStr, ' ');
			std::wstring backgroundEntry = L"";

			// March22 handles events and backgrounds the same way
			if (splitStr.at(1) == L"ev" || splitStr.at(1) == L"bg") 
			{
				bool alreadyLoaded = false;
				for (size_t ch = 0; ch < loadedBackgroundsTemp.size(); ch++)
				{
					if (loadedBackgroundsTemp.at(ch) == splitStr.at(2))
					{
						alreadyLoaded = true;
						break;
					};
				}
				if (!alreadyLoaded)
				{
					backgroundEntry += L"LoadBackground(\"";
					backgroundEntry += splitStr.at(2);
					backgroundEntry += L"\");\n";
					result.push_back(backgroundEntry);
					loadedBackgroundsTemp.push_back(splitStr.at(2));
				};
			}
			else if (splitStr.at(1) == L"bl") // black
			{

			}
			else if (splitStr.at(1) == L"wh") // white
			{

			};
		};
	}

	return result;
}

unsigned int SplitString(const std::wstring &txt, std::vector<std::wstring> &strs, char ch)
{
	unsigned int pos = txt.find(ch);
	unsigned int initialPos = 0;
	strs.clear();

	// Decompose statement
	while (pos != std::string::npos) {
		strs.push_back(txt.substr(initialPos, pos - initialPos + 1));
		initialPos = pos + 1;

		pos = txt.find(ch, initialPos);
	}

	// Add the last one
	strs.push_back(txt.substr(initialPos, std::min(pos, txt.size()) - initialPos + 1));

	for (size_t i = 0; i < strs.size(); i++)
	{
		strs.at(i).erase(std::remove_if(strs.at(i).begin(), strs.at(i).end(), iswspace), strs.at(i).end());
	}

	return strs.size();
};

int LoadScriptIntoVector(const wchar_t* _input, std::vector<std::wstring>& _vector)
{
	// Load file
	std::locale ulocale(std::locale(), new std::codecvt_utf8<wchar_t>);
	std::wifstream inputFile;
	inputFile.open(_input);
	inputFile.imbue(ulocale);

	// Check file
	if (!inputFile) {
		wprintf(L"Failed to load: %s\n", _input);
		return -1;
	};

	// Load meaningful lines into vector
	std::wstring line;
	while (std::getline(inputFile, line))
	{
		if (line != L"") {
			//std::wstringstream iss(line);
			//::wstring item;
			//iss >> item;

			_vector.push_back(line);
		};
	};
	inputFile.seekg(0, inputFile.beg);

	// Cleanup
	inputFile.close();
	return 0;
};